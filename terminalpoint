#!/usr/bin/env ruby

require 'io/console'

ROWS = IO.console.winsize[0] - 1   # leave one for the `less` status bar
COLS = IO.console.winsize[1]
CONFIG = {
	"title.color" => "bold",
	"title.position" => "center",  # or "left", or "right", or "content-center"
	"title.box" => "none", # or any combination of "top", "bottom", "left", "right", "double"; "box" means "top bottom left right"
	"title.box.color" => "plain",
	"table.header.color" => "bold",
	"table.position" => "center",  # or "left", or "right"
	"bullet.color" => "plain",
	"text.color" => "plain",
	"bullet.text" => "»",
	"pad.top" => 2,
	"pad.left" => 3,
	"pad.right" => 2,
	"pad.title" => 2,
	"code.color" => "bold bg:dark-grey",
}
COLOR = {
	"bold" => "1",
	"italic" => "3",
	"underlined" => "4",
	"red" => "31",
	"green" => "32",
	"brown" => "33",
	"blue" => "34",
	"magenta" => "35",
	"cyan" => "36",
	"grey" => "37",
	"dark-grey" => "90",
	"bright-red" => "91",
	"bright-green" => "92",
	"yellow" => "93",
	"bright-blue" => "94",
	"bright-magenta" => "95",
	"bright-cyan" => "96",
	"white" => "97",
	"pink" => "38;5;206",
	"orange" => "38;5;202",
	"purple" => "38;5;91",
}

class Entry
	def display_width(s)
		TerminalPoint.display_width(s)
	end

	def wrap_text(text, max_length)
		words = text.split(/\s+/)
		lines = []
		line = ""

		words.each do |word|
			if line.empty?
				line = word
			elsif (display_width(line) + 1 + display_width(word)) <= max_length
				line += " " + word
			else
				lines << line
				line = word
			end
		end

		lines << line unless line.empty?
		lines
	end

	# Convert simple markdown formatting to ANSI sequences.  Supported:
	# **bold**, __bold__, *italics*, _underlines_, and `backticks`
	def mini_markdown(s)
		# Backticks prevent other markdown formatting, so we split the string
		# according to backticks and apply other markdown formatting only
		# in the even-numbered segments and the last segment.
		split = s.split(/`/, -1)
		split = split.each_with_index.map{|tok, i|
			if i % 2 == 0 || i == split.size - 1
				tok.
					gsub(/~([^~]*)~/) { |txt| TerminalPoint.ansi(9, txt[1..-2]) }.
					gsub(/\*\*([^*]*)\*\*/) { |txt| TerminalPoint.ansi(1, txt[2..-3]) }.
					gsub(/__([^_]*)__/) { |txt| TerminalPoint.ansi(1, txt[2..-3]) }.
					gsub(/\*(\w[^*]*)\*/) { |txt| TerminalPoint.ansi(3, txt[1..-2]) }.
					gsub(/\b_([^_]*)_\b/) { |txt| TerminalPoint.ansi(4, txt[1..-2]) }
			else
				TerminalPoint.fmt(CONFIG['code.color'], tok)
			end
		}

		# If we had an odd number of backticks, then the last one shows up as
		# a literal ` character.
		if split.size % 2 == 0
			split[..-2].join + "`" + split[-1]
		else
			split.join
		end
	end

	def invert_color(col)
		col.split(/\s+/).map {|c|
			case c
				when /^bg:$1/
					$1
				else
					if COLOR[c].size >= 2
						# ANSI color codes are all 2+ characters
						"bg:#{c}"
					else
						# Supported ANSI font styles are all 1 character
						c
					end
			end
		}.join(' ')
	end

	def borrow_formatting(s, parts)
		if !s.start_with?("\e[")
			if parts.join(' ') =~ /.*(\e\[[0-9;]+m)/
				s = $1 + s
			end
		end

		if !s.end_with?("\e[0m")
			s = s + "\e[0m"
		end

		s
	end
end

class Title < Entry
	def initialize(txt)
		@txt = mini_markdown(txt)
		@title_box = CONFIG['title.box']
		@title_color = CONFIG['title.color']
		@title_box_color = CONFIG['title.box.color']
		@title_position = CONFIG['title.position']
		@pad_left = CONFIG['pad.left']
		@pad_right = CONFIG['pad.right']
		@pad_title = CONFIG['pad.title']
	end

	def width
		display_width(@txt)
	end

	def display(max_content_width)
		title_box = @title_box.downcase.split
		box_dbl = title_box.include?('double')
		box_box = title_box.include?('box')
		box_l = box_box || title_box.include?('left')
		box_r = box_box || title_box.include?('right')
		box_t = box_box || title_box.include?('top')
		box_b = box_box || title_box.include?('bottom')
		box_bar = title_box.include?('bar')

		real_txt = TerminalPoint.fmt(@title_color, @txt)
		real_txt = (TerminalPoint.fmt(@title_box_color, (box_dbl ? "║ " : '│ ')) + real_txt) if box_l
		real_txt = (real_txt + TerminalPoint.fmt(@title_box_color, (box_dbl ? " ║" : ' │'))) if box_r

		left_title_pad = " " * case @title_position
			when "center"
				(COLS - display_width(real_txt))/2
			when "left"
				@pad_left
			when "right"
				COLS - @pad_right - display_width(real_txt)
			when "content-center"
				@pad_left + (max_content_width - display_width(real_txt))/2
			else
				raise "unknown title.position: #{@title_position}"
		end
		below_title_pad = "\n" * @pad_title
		if box_bar
			sides_color = invert_color(@title_box_color)
			puts TerminalPoint.fmt(@title_box_color, "▄" * COLS)
			print TerminalPoint.fmt(sides_color, left_title_pad)
			print TerminalPoint.fmt(@title_color, @txt)
			puts TerminalPoint.fmt(sides_color, " " * (COLS - left_title_pad.size - display_width(@txt)))
			puts TerminalPoint.fmt(@title_box_color, "▀" * COLS)
		else
			if box_t
				top_line = ""
				top_line << (box_dbl ? "╔═" : "┌─") if box_l
				top_line << (box_dbl ? "═" : "─") * display_width(@txt)
				top_line << (box_dbl ? "═╗" : "─┐") if box_r
				puts left_title_pad + TerminalPoint.fmt(@title_box_color, top_line)
			end

			puts "#{left_title_pad}#{real_txt}"

			if box_b
				bottom_line = ""
				bottom_line << (box_dbl ? "╚═" : "└─") if box_l
				bottom_line << (box_dbl ? "═" : "─") * display_width(@txt)
				bottom_line << (box_dbl ? "═╝" : "─┘") if box_r
				puts left_title_pad + TerminalPoint.fmt(@title_box_color, bottom_line)
			end
		end
		puts below_title_pad

		1 + below_title_pad.size + (box_t ? 1 : 0) + (box_b ? 1 : 0) + (box_bar ? 2 : 0)
	end
end

class Bullet < Entry
	def initialize(*args)
		indent, txt = case args.size
			when 1
				[ 1, args[0] ]
			when 2
				[ args[0], args[1] ]
			else
				raise "Invalid arguments to bullet"
		end

		@txt = mini_markdown(txt)
		@bullet_text = TerminalPoint.fmt(CONFIG['bullet.color'], CONFIG['bullet.text'])
		@pad_indent = 4 * (indent - 1)
		@pad_left = CONFIG['pad.left'] + @pad_indent
		@pad_right = CONFIG['pad.right']
		@text_color = CONFIG['text.color']
		@wrap_width = COLS - @pad_left - display_width(@bullet_text) - 1 - @pad_right
	end

	def width
		display_width(@bullet_text) + 1 + [ @pad_indent + display_width(@txt), @wrap_width ].min
	end

	def display(max_content_width)
		bullet_pad = " " * @pad_left

		fmt_txt = TerminalPoint.fmt(@text_color, @txt)
		split = wrap_text(fmt_txt, @wrap_width)
		split.each_with_index do |part, j|
			print bullet_pad
			if j == 0
				print @bullet_text
			else
				print " " * display_width(@bullet_text)
			end
			print " "
			puts borrow_formatting(part, split[...j])
		end

		puts

		split.size + 1
	end
end

class Table < Entry
	def initialize(arr)
		arr = arr.map {|row|
			if row.is_a?(Array)
				row.map{|col| mini_markdown(col)}
			else
				row
			end
		}

		ncolumns = arr.map {|row| row.size if row.is_a?(Array)}.compact.max
		col_widths = (0...ncolumns).map do |col|
			arr.map {|row| display_width(row[col]) if row.is_a?(Array)}.compact.max
		end
		min_widths = (0...ncolumns).map do |col|
			arr.map {|row| row[col].split(/\s+/).map {|word| display_width(word)}.max if row.is_a?(Array)}.compact.max
		end
		twidth = col_widths.sum + ncolumns*3 + 1

		while twidth >= COLS
			col_widths = col_widths.zip(min_widths).map {|w, minw|
				[w * 9 / 10, minw].max
			}
			new_twidth = col_widths.sum + ncolumns*3 + 1
			raise "Table does not fit" if new_twidth == twidth
			twidth = new_twidth
		end

		@arr = arr
		@twidth = twidth
		@col_widths = col_widths

		@table_position = CONFIG['table.position']
		@table_header_color = CONFIG['table.header.color']
		@pad_left = CONFIG['pad.left']
		@pad_right = CONFIG['pad.right']
	end

	def width
		@twidth
	end

	def display(max_content_width)
		lines = 0

		left_pad = " " * case @table_position
			when "left"
				@pad_left
			when "center"
				(COLS - @twidth)/2
			when "right"
				COLS - @pad_right - @twidth
			else
				raise "unknown table.position: #{@table_position}"
		end

		is_header = false
		puts "#{left_pad}╔" + ("═" * (@twidth-2)) + "╗"
		lines += 1
		@arr.each do |row|
			if row == :header
				is_header = true
				next
			end

			cell_row = 0
			more_cell_rows = true

			while more_cell_rows
				more_cell_rows = false
				print "#{left_pad}║"
				row.zip(@col_widths).each_with_index do |(cell, w), i|
					print is_header ? " " : "│" if i > 0
					print " "
					cell_parts = wrap_text(cell, w)
					if cell_parts.size > cell_row
						cell_part = cell_parts[cell_row]
						more_cell_rows ||= cell_parts.size > cell_row + 1
						if is_header
							print TerminalPoint.fmt(@table_header_color, borrow_formatting(cell_part, cell_parts[...cell_row]))
						else
							print borrow_formatting(cell_part, cell_parts[...cell_row])
						end
						pad = w + 1 - display_width(cell_part)
						print " " * pad
					else
						print " " * (w + 1)
					end
				end
				puts "║"
				lines += 1
				cell_row += 1
			end

			if is_header
				puts "#{left_pad}╠" + @col_widths.map{|w| "═" * (w+2)}.join("╤") + "╣"
				lines += 1
			elsif row != @arr.last
				puts "#{left_pad}╟" + @col_widths.map{|w| "─" * (w+2)}.join("┼") + "╢"
				lines += 1
			end

			is_header = false
		end
		puts "#{left_pad}╚" + @col_widths.map{|w| "═" * (w+2)}.join("╧") + "╝"
		puts
		lines += 2

		lines
	end
end

class Pre < Entry
	def initialize(txt)
		@txt = txt
	end

	def width
		@txt.lines.map(&:size).max
	end

	def display(max_content_width)
		puts @txt
		puts
		@txt.lines.size + 1
	end
end

class Slide
	def initialize
		@entries = []

		@pad_top = CONFIG['pad.top']
	end

	def display
		max_content_width = @entries.map{|s| s.width}.max

		top_pad = "\n" * @pad_top
		puts top_pad
		lines = top_pad.size

		lines += @entries.map { |e| e.display(max_content_width) }.sum

		puts "\n" * (ROWS - lines)
	end

	def <<(ent)
		@entries << ent
	end

	def empty?
		!@title.nil? || !@bullets.empty?
	end
end

class TerminalPoint
	def initialize(start_slide)
		@current_slide = nil
		@start_slide = start_slide  # TODO
	end

	# [DSL] begin a new slide
	def slide
		@current_slide.display if @current_slide
		@current_slide = Slide.new
	end

	# [DSL] pause for input before displaying the next element
	def build
		@current_slide.display if @current_slide
	end

	# [DSL] add a title element to the slide
	#   s: markdown or ANSI text to display
	def title(s)
		@current_slide << Title.new(s)
	end

	# [DSL] add a bullet element to the slide
	#   s: markdown or ANSI text to display
	def bullet(*args)
		@current_slide << Bullet.new(*args)
	end

	# [DSL] add a table element to the slide
	#   t: an array of table rows.  Each row is an array of markdown or ANSI text for a cell.
	#      A special row value :header indicates that the next row should be displayed as a header.
	def table(t)
		@current_slide << Table.new(t)
	end

	# [DSL] add a fixed-format element to the slide
	#   txt: text to be displayed verbatim, including newlines.  No markdown processing occurs.
	def pre(txt)
		@current_slide << Pre.new(txt)
	end

	# [DSL] center a `pre` element on the slide
	# Usage:
	#   pre center 'something'
	def center(txt)
		txt = txt.lines
		max_width = txt.map {|s| TerminalPoint.display_width(s)}.max
		left_pad = " " * ((COLS - max_width)/2)
		txt.map {|s| "#{left_pad}#{s}"}.join("")
	end

	# [DSL] change the value of a configuration key
	#   key: the key, which must exist in the default CONFIG hash
	#   value: the value, which must be the same class as the default value
	def config(key, value=nil)
		if key == :default
			DEFAULTS.each { |k, v| CONFIG[k] = v }
			return
		end

		raise "Unknown config key #{key}" unless CONFIG.has_key?(key)
		if value == :default
			CONFIG[key] = DEFAULTS[key].dup
			return
		end

		raise "Config key #{key} must be a #{CONFIG[key].class}" unless value.is_a?(CONFIG[key].class)
		CONFIG[key] = value
	end

	# [DSL] set a custom color, which can be used in config and fmt commands
	#   key: the name of the new color
	#   value: either a string-separated list of COLOR keys, like 'bold red', or a hex value like '#ffccaa'
	def color(key, value)
		COLOR[key] = TerminalPoint.color_to_codes(value)
	end

	# [DSL] decorate the text with a list of selectors
	#   col: one or more selectors, as a space-separated string.  Each selector is either a key in the
	#        COLOR array or a hex code.  E.g., "bg:green #ff0000 italic"
	#   s: the string to decorate
	# Example:
	#   fmt('bg:green #ff0000 italic', 'Ugly!')
	def fmt(col, s)
		TerminalPoint.fmt(col, s)
	end

	# [DSL] decorate the text with rainbow colors
	#   s: the string to decorate
	def rainbow(s)
		colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
		s.chars.each_with_index.map{|c, i| fmt(colors[i % colors.size], c)}.join
	end

	def TerminalPoint.display_width(s)
		s.gsub(/\x1b\[[0-9;]+m/, '').size
	end

	# Map a logical format to a string of ANSI codes
	#   col: any key from the COLOR array, or a hex code like "#ffccaa"
	#   returns: the numeric part of an ANSI sequence, like "31;1" for bold red
	def TerminalPoint.color_to_codes(col)
		col.split(/\s+/).map {|one_color|
			if one_color =~ /^bg:/
				one_color = one_color[3..]
				bg = true
			end

			code = if COLOR.has_key?(one_color)
				COLOR[one_color]
			elsif one_color =~ /^#[0-9a-fA-F]{6}$/
				red = one_color[1..2].hex
				green = one_color[3..4].hex
				blue = one_color[5..6].hex
				"38;2;#{red};#{green};#{blue}"
			else
				raise "Unknown color: #{one_color}"
			end

			if bg
				codes = code.split(/;/)
				codes[0] = (codes[0].to_i + 10).to_s
				code = codes.join(';')
			end

			code
		}.join(';')
	end

	# Apply a logical format to a string
	#   col: a space-separated list of color keys, which are either keys from the COLOR array, or a hex code like "#ffccaa"
	#   s: the string to decorate
	#   returns: s, with the ANSI codes selected by col applied
	def TerminalPoint.fmt(col, s)
		return s if col == "plain"
		code = color_to_codes(col)
		ansi(code, s)
	end

	# Apply a sequence of ANSI codes to a string.
	#   codes: just the numeric part of the code, like "31;1" for bold red
	#   s: the string to decorate, which might already have some ANSI in it
	#   returns: s, with the codes wrapped around it
	def TerminalPoint.ansi(codes, s)
		# If there are already ANSI codes in `s`, like from the user using `#{fmt('bold', '...')}` in their config file
		# rewrite the end of those sequences to apply the overall formatting for the string.
		sfix = s.gsub("\x1b[0m", "\x1b[0;#{codes}m")
		"\x1b[0;#{codes}m#{sfix}\x1b[0m"
	end
end

def usage
	puts "Usage:"
	puts "  #{$0} [--slide N]"
	puts "  #{$0} [--config] [--colors]"
end

start_slide = 1

while ARGV.first =~ /^--/
	arg = ARGV.shift
	case arg
		when "--config"
			CONFIG.each do |key, value|
				puts "CONFIG[#{key.inspect}] = #{value.inspect}"
			end
			quit_now = true
		when "--colors"
			COLOR.each do |key, value|
				puts "COLOR[#{key.inspect}] = #{value.inspect}"
			end
			quit_now = true
		when "--slide"
			start_slide = ARGV.shift.to_i
		when "--help"
			usage
			quit_now = true
		else
			puts "Unknown argument: #{arg}"
			usage
			quit_now = true
	end
end
exit 0 if quit_now

DEFAULTS = CONFIG.dup
		
tp = TerminalPoint.new(start_slide)
tp.instance_eval(ARGF.read)
tp.build
