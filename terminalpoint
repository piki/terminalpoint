#!/usr/bin/env ruby

require 'io/console'

ROWS = IO.console.winsize[0] - 1   # leave one for the `less` status bar
COLS = IO.console.winsize[1]
CONFIG = {
	"title.color" => "bold",
	"title.position" => "center",  # or "left", or "right", or "block-center"
	"title.box" => "none", # or any combination of "top", "bottom", "left", "right", "double"; "box" means "top bottom left right"
	"title.box.color" => "plain",
	"table.header.color" => "bold",
	"table.position" => "center",  # or "left", or "right"
	"bullet.color" => "plain",
	"text.color" => "plain",
	"bullet.text" => "»",
	"pad.top" => 2,
	"pad.left" => 3,
	"pad.right" => 2,
	"pad.title" => 2,
	"code.color" => "bold bg:dark-grey",
}
COLOR = {
	"bold" => "1",
	"italic" => "3",
	"underlined" => "4",
	"red" => "31",
	"green" => "32",
	"brown" => "33",
	"blue" => "34",
	"magenta" => "35",
	"cyan" => "36",
	"grey" => "37",
	"dark-grey" => "90",
	"bright-red" => "91",
	"bright-green" => "92",
	"yellow" => "93",
	"bright-blue" => "94",
	"bright-magenta" => "95",
	"bright-cyan" => "96",
	"white" => "97",
	"pink" => "38;5;206",
	"orange" => "38;5;202",
}

class Entry
	def display_width(s)
		s.gsub(/\x1b\[[0-9;]+m/, '').size
	end

	def wrap_text(text, max_length)
		words = text.split(/\s+/)
		lines = []
		line = ""

		words.each do |word|
			#puts "word = #{word.inspect}"
			#puts "word.size = #{word.length}"
			#puts "word.display_size = #{display_width(word)}"
			if line.empty?
				line = word
			elsif (display_width(line) + 1 + display_width(word)) <= max_length
				line += " " + word
			else
				lines << line
				line = word
			end
		end

		lines << line unless line.empty?
		lines
	end
end

class Title < Entry
	def initialize(txt)
		@txt = txt
	end

	def width
		@txt.size
	end

	def display(max_content_width)
		title_box = CONFIG['title.box'].downcase.split
		box_dbl = title_box.include?('double')
		box_box = title_box.include?('box')
		box_l = box_box || title_box.include?('left')
		box_r = box_box || title_box.include?('right')
		box_t = box_box || title_box.include?('top')
		box_b = box_box || title_box.include?('bottom')

		real_txt = TerminalPoint.fmt(CONFIG['title.color'], @txt)
		real_txt = (TerminalPoint.fmt(CONFIG['title.box.color'], (box_dbl ? "║ " : '│ ')) + real_txt) if box_l
		real_txt = (real_txt + TerminalPoint.fmt(CONFIG['title.box.color'], (box_dbl ? " ║" : ' │'))) if box_r

		left_title_pad = " " * case CONFIG['title.position']
			when "center"
				(COLS - display_width(real_txt))/2
			when "left"
				CONFIG['pad.left']
			when "right"
				COLS - CONFIG['pad.right'] - display_width(real_txt)
			when "block-center"
				CONFIG['pad.left'] + (max_content_width + CONFIG['bullet.text'].size + 1 - display_width(real_txt))/2
			else
				raise "unknown title.position: #{CONFIG['title.position']}"
		end
		below_title_pad = "\n" * CONFIG['pad.title']
		if box_t
			top_line = ""
			top_line << (box_dbl ? "╔═" : "┌─") if box_l
			top_line << (box_dbl ? "═" : "─") * display_width(@txt)
			top_line << (box_dbl ? "═╗" : "─┐") if box_r
			puts left_title_pad + TerminalPoint.fmt(CONFIG['title.box.color'], top_line)
		end
		puts "#{left_title_pad}#{real_txt}"
		if box_b
			bottom_line = ""
			bottom_line << (box_dbl ? "╚═" : "└─") if box_l
			bottom_line << (box_dbl ? "═" : "─") * display_width(@txt)
			bottom_line << (box_dbl ? "═╝" : "─┘") if box_r
			puts left_title_pad + TerminalPoint.fmt(CONFIG['title.box.color'], bottom_line)
		end
		puts below_title_pad

		1 + below_title_pad.size + (box_t ? 1 : 0) + (box_b ? 1 : 0)
	end
end

class Bullet < Entry
	def initialize(txt)
		@txt = txt
	end

	def width
		display_width(@txt)
	end

	def display(max_content_width)
		bullet_pad = " " * CONFIG['pad.left']

		split = wrap_text(@txt, COLS - bullet_pad.size - CONFIG['bullet.text'].size - 1 - CONFIG['pad.right'])
		split.each_with_index do |part, j|
			print bullet_pad
			if j == 0
				print TerminalPoint.fmt(CONFIG['bullet.color'], CONFIG['bullet.text'])
			else
				print " " * CONFIG['bullet.text'].size
			end
			print " "
			puts TerminalPoint.fmt(CONFIG['text.color'], part)
		end

		puts

		split.size + 1
	end
end

class Table < Entry
	def initialize(arr)
		@arr = arr

		ncolumns = arr.map {|row| row.size if row.is_a?(Array)}.compact.max
		col_widths = (0...ncolumns).map do |col|
			arr.map {|row| display_width(row[col]) if row.is_a?(Array)}.compact.max
		end
		min_widths = (0...ncolumns).map do |col|
			arr.map {|row| row[col].split(/\s+/).map {|word| display_width(word)}.max if row.is_a?(Array)}.compact.max
		end
		twidth = col_widths.sum + ncolumns*3 + 1

		while twidth >= COLS
			col_widths = col_widths.zip(min_widths).map {|w, minw|
				[w * 9 / 10, minw].max
			}
			new_twidth = col_widths.sum + ncolumns*3 + 1
			raise "Table does not fit" if new_twidth == twidth
			twidth = new_twidth
		end

		@arr = arr
		@twidth = twidth
		@col_widths = col_widths
	end

	def width
		@twidth
	end

	def display(max_content_width)
		lines = 0

		left_pad = " " * case CONFIG['table.position']
			when "left"
				CONFIG['pad.left']
			when "center"
				(COLS - @twidth)/2
			when "right"
				COLS - CONFIG['pad.right'] - @twidth
			else
				raise "unknown table.position: #{CONFIG['table.position']}"
		end

		is_header = false
		puts "#{left_pad}╔" + ("═" * (@twidth-2)) + "╗"
		lines += 1
		@arr.each do |row|
			if row == :header
				is_header = true
				next
			end

			cell_row = 0
			more_cell_rows = true

			while more_cell_rows
				more_cell_rows = false
				print "#{left_pad}║"
				row.zip(@col_widths).each_with_index do |(cell, w), i|
					print is_header ? " " : "│" if i > 0
					print " "
					cell_parts = wrap_text(cell, w)
					if cell_parts.size > cell_row
						cell_part = cell_parts[cell_row]
						more_cell_rows ||= cell_parts.size > cell_row + 1
						if is_header
							print TerminalPoint.fmt(CONFIG['table.header.color'], borrow_formatting(cell_part, cell_parts[...cell_row]))
						else
							print borrow_formatting(cell_part, cell_parts[...cell_row])
						end
						pad = w + 1 - display_width(cell_part)
						print " " * pad
					else
						print " " * (w + 1)
					end
				end
				puts "║"
				lines += 1
				cell_row += 1
			end

			if is_header
				puts "#{left_pad}╠" + @col_widths.map{|w| "═" * (w+2)}.join("╤") + "╣"
				lines += 1
			elsif row != @arr.last
				puts "#{left_pad}╟" + @col_widths.map{|w| "─" * (w+2)}.join("┼") + "╢"
				lines += 1
			end

			is_header = false
		end
		puts "#{left_pad}╚" + @col_widths.map{|w| "═" * (w+2)}.join("╧") + "╝"
		puts
		lines += 2

		lines
	end

private
	def borrow_formatting(s, parts)
		if !s.start_with?("\e[")
			if parts.join(' ') =~ /.*(\e\[[0-9;]+m)/
				s = $1 + s
			end
		end

		if !s.end_with?("\e[0m")
			s = s + "\e[0m"
		end

		s
	end
end

class Pre < Entry
	def initialize(txt)
		@txt = txt
	end

	def width
		@txt.lines.map(&:size).max
	end

	def display(max_content_width)
		puts @txt
		puts
		@txt.lines.size + 1
	end
end

class Slide
	def initialize
		@entries = []
	end

	def display
		wrap_width = COLS - CONFIG['pad.left'] - CONFIG['bullet.text'].size - 1 - CONFIG['pad.right']

		max_content_width = @entries.map{|s| s.width}.max
		max_content_width = [max_content_width, wrap_width].min

		top_pad = "\n" * CONFIG['pad.top']
		puts top_pad
		lines = top_pad.size

		lines += @entries.map { |e| e.display(max_content_width) }.sum

		puts "\n" * (ROWS - lines)
	end

	def title(s)
		@entries << Title.new(mini_markdown(s))
	end

	def bullet(s)
		@entries << Bullet.new(mini_markdown(s))
	end

	def table(t)
		@entries << Table.new(
			t.map {|row|
				if row.is_a?(Array)
					row.map{|col| mini_markdown(col)}
				else
					row
				end
			}
		)
	end

	def pre(txt)
		@entries << Pre.new(txt)
	end

	def empty?
		!@title.nil? || !@bullets.empty?
	end

private
	# Convert simple markdown formatting to ANSI sequences.  Supported:
	# **bold**, __bold__, *italics*, _underlines_, and `backticks`
	def mini_markdown(s)
		# Backticks prevent other markdown formatting, so we split the string
		# according to backticks and apply other markdown formatting only
		# in the even-numbered segments and the last segment.
		split = s.split(/`/, -1)
		split = split.each_with_index.map{|tok, i|
			if i % 2 == 0 || i == split.size - 1
				tok.
					gsub(/~([^~]*)~/) { |txt| TerminalPoint.ansi(9, txt[1..-2]) }.
					gsub(/\*\*([^*]*)\*\*/) { |txt| TerminalPoint.ansi(1, txt[2..-3]) }.
					gsub(/__([^_]*)__/) { |txt| TerminalPoint.ansi(1, txt[2..-3]) }.
					gsub(/\*(\w[^*]*)\*/) { |txt| TerminalPoint.ansi(3, txt[1..-2]) }.
					gsub(/\b_([^_]*)_\b/) { |txt| TerminalPoint.ansi(4, txt[1..-2]) }
			else
				TerminalPoint.fmt(CONFIG['code.color'], tok)
			end
		}

		# If we had an odd number of backticks, then the last one shows up as
		# a literal ` character.
		if split.size % 2 == 0
			split[..-2].join + "`" + split[-1]
		else
			split.join
		end
	end
end

class TerminalPoint
	def initialize
		@current_slide = nil
	end

	# [DSL] begin a new slide
	def slide
		@current_slide.display if @current_slide
		@current_slide = Slide.new
	end

	# [DSL] pause for input before displaying the next element
	def build
		@current_slide.display if @current_slide
	end

	# [DSL] add a title element to the slide
	#   s: markdown or ANSI text to display
	def title(s)
		@current_slide.title(s)
	end

	# [DSL] add a bullet element to the slide
	#   s: markdown or ANSI text to display
	def bullet(s)
		@current_slide.bullet(s)
	end

	# [DSL] add a table element to the slide
	#   t: an array of table rows.  Each row is an array of markdown or ANSI text for a cell.
	#      A special row value :header indicates that the next row should be displayed as a header.
	def table(t)
		@current_slide.table(t)
	end

	# [DSL] add a fixed-format element to the slide
	#   txt: text to be displayed verbatim, including newlines.  No markdown processing occurs.
	def pre(txt)
		@current_slide.pre(txt)
	end

	# [DSL] center a `pre` element on the slide
	# Usage:
	#   pre center 'something'
	def center(txt)
		txt = txt.lines
		max_width = txt.map {|s| s.size}.max
		left_pad = " " * ((COLS - max_width)/2)
		txt.map {|s| "#{left_pad}#{s}"}.join("")
	end

	# [DSL] change the value of a configuration key
	#   key: the key, which must exist in the default CONFIG hash
	#   value: the value, which must be the same class as the default value
	def config(key, value=nil)
		if key == :default
			DEFAULTS.each { |k, v| CONFIG[k] = v }
			return
		end

		raise "Unknown config key #{key}" unless CONFIG.has_key?(key)
		if value == :default
			CONFIG[key] = DEFAULTS[key].dup
			return
		end

		raise "Config key #{key} must be a #{CONFIG[key].class}" unless value.is_a?(CONFIG[key].class)
		CONFIG[key] = value
	end

	# [DSL] set a custom color, which can be used in config and fmt commands
	#   key: the name of the new color
	#   value: either a string-separated list of COLOR keys, like 'bold red', or a hex value like '#ffccaa'
	def color(key, value)
		COLOR[key] = TerminalPoint.color_to_codes(value)
	end

	# [DSL] decorate the text with a list of selectors
	#   col: one or more selectors, as a space-separated string.  Each selector is either a key in the
	#        COLOR array or a hex code.  E.g., "bg:green #ff0000 italic"
	#   s: the string to decorate
	# Example:
	#   fmt('bg:green #ff0000 italic', 'Ugly!')
	def fmt(col, s)
		TerminalPoint.fmt(col, s)
	end

	# Map a logical format to a string of ANSI codes
	#   col: any key from the COLOR array, or a hex code like "#ffccaa"
	#   returns: the numeric part of an ANSI sequence, like "31;1" for bold red
	def TerminalPoint.color_to_codes(col)
		col.split(/\s+/).map {|one_color|
			if one_color =~ /^bg:/
				one_color = one_color[3..]
				bg = true
			end

			code = if COLOR.has_key?(one_color)
				COLOR[one_color]
			elsif one_color =~ /^#[0-9a-fA-F]{6}$/
				red = one_color[1..2].hex
				green = one_color[3..4].hex
				blue = one_color[5..6].hex
				"38;2;#{red};#{green};#{blue}"
			else
				raise "Unknown color: #{one_color}"
			end

			if bg
				codes = code.split(/;/)
				codes[0] = (codes[0].to_i + 10).to_s
				code = codes.join(';')
			end

			code
		}.join(';')
	end

	# Apply a logical format to a string
	#   col: a space-separated list of color keys, which are either keys from the COLOR array, or a hex code like "#ffccaa"
	#   s: the string to decorate
	#   returns: s, with the ANSI codes selected by col applied
	def TerminalPoint.fmt(col, s)
		return s if col == "plain"
		code = color_to_codes(col)
		ansi(code, s)
	end

	# Apply a sequence of ANSI codes to a string.
	#   codes: just the numeric part of the code, like "31;1" for bold red
	#   s: the string to decorate, which might already have some ANSI in it
	#   returns: s, with the codes wrapped around it
	def TerminalPoint.ansi(codes, s)
		# If there are already ANSI codes in `s`, like from the user using `#{fmt('bold', '...')}` in their config file
		# rewrite the end of those sequences to apply the overall formatting for the string.
		sfix = s.gsub("\x1b[0m", "\x1b[0;#{codes}m")
		"\x1b[#{codes}m#{sfix}\x1b[0m"
	end
end

while ARGV.first =~ /^--/
	quit_now = true
	arg = ARGV.shift
	case arg
		when "--config"
			CONFIG.each do |key, value|
				puts "CONFIG[#{key.inspect}] = #{value.inspect}"
			end
		when "--colors"
			COLOR.each do |key, value|
				puts "COLOR[#{key.inspect}] = #{value.inspect}"
			end
		else
			raise "Unknown argument: #{arg}"
	end
end
exit 0 if quit_now

DEFAULTS = CONFIG.dup
		
tp = TerminalPoint.new
tp.instance_eval(ARGF.read)
tp.build
